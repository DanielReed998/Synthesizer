module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	 * Copyright (c) 2015 Gary Haussmann
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	//
	// Lots of code here is based on react-art: https://github.com/facebook/react-art
	//

	"use strict";

	var React = __webpack_require__(1);
	var ReactDOM = __webpack_require__(2);

	var ReactUpdates = __webpack_require__(4);
	var ReactMultiChild = __webpack_require__(5);

	var assign = __webpack_require__(6);
	var emptyObject = __webpack_require__(7);

	// monkey patch to workaround React's assumption that we're working only with DOM elements
	var monkeypatch = __webpack_require__(9);
	monkeypatch();

	//
	// Generates a React component by combining several mixin components
	//

	function defineWebAudioComponent(name) {

	  var ReactWebAudioComponent = function ReactWebAudioComponent() {
	    /* jshint unused: vars */
	    this.node = null;
	    this._mountImage = null;
	    this._audioNode = null;
	    this._audioContext = null;
	    this._audioConnections = null;
	    this._renderedChildren = null;
	  };
	  ReactWebAudioComponent.displayName = name;
	  for (var i = 1; i < arguments.length; i++) {
	    assign(ReactWebAudioComponent.prototype, arguments[i]);
	  }

	  return ReactWebAudioComponent;
	}

	//
	// track audiocontexts and their IDs for lookup later
	//

	var AudioContexts = {};

	function findAudioContext(nodeID) {
	  // find the audio context with a matching id prefix
	  for (var audiocontextID in AudioContexts) {
	    // cut down the nodeID to match lengths with the audiocontext IDs
	    var subnodeID = nodeID.substr(0, audiocontextID.length);

	    // do they match? if so, this is the ancestor audiocontext
	    if (subnodeID === audiocontextID) {
	      return AudioContexts[audiocontextID];
	    }
	  }

	  // no matches found
	  return undefined;
	}

	function addAudioContext(rootnodeID, context) {
	  AudioContexts[rootnodeID] = context;
	}

	function removeAudioContext(rootnodeID, context) {
	  /* jshint unused: vars */
	  delete AudioContexts[rootnodeID];
	}

	//
	// A Web Audio Node gets inputs from all of its children (assuming no sidechaining)
	// and emits audio up to its parent (note: parent not owner).
	//

	// OutputAudioNodes have only outputs, and thus (in react-webaudio) they have no children.
	// AudioNodes have (usually) both inputs and outputs

	//
	// If you're making an AudioNode component,
	// mixin these methods and implement your own version of
	// createAudioNode and applySpecificAudioNodeProps
	//

	var OutputAudioNodeMixin = {

	  construct: function construct(element) {
	    this._currentElement = element;
	    this._audioNode = null;
	    this._audioContext = null;
	    this._audioConnections = [];
	    this._parentNode = null;
	    this._playState = null;
	  },

	  getPublicInstance: function getPublicInstance() {
	    return this._audioNode;
	  },

	  mountComponent: function mountComponent(rootID, transaction, context) {
	    /* jshint unused: vars */
	    var props = this._currentElement.props;
	    this._audioContext = findAudioContext(rootID);
	    var newnode = this.buildAudioNode();
	    this.applyAudioNodeProps({}, props);
	    return newnode;
	  },

	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    /* jshint unused: vars */
	    var oldProps = this._currentElement.props;
	    var props = nextElement.props;

	    // might need to rebuild/restart the node
	    if (this.shouldRebuildNode && this.shouldRebuildNode(oldProps, props)) {
	      this.rebuildAudioNode();
	    } else {
	      this.applyAudioNodeProps(oldProps, props);
	      this.applySpecificAudioNodeProps(oldProps, props);
	    }

	    this._currentElement = nextElement;
	  },

	  unmountComponent: function unmountComponent() {},

	  applyAudioNodeProps: function applyAudioNodeProps(oldProps, props) {
	    /* jshint unused: vars */
	  },

	  connectAudio: function connectAudio(connecttarget) {
	    this._audioNode.connect(connecttarget._audioNode);
	    this._audioConnections.push(connecttarget);
	  },

	  disconnectAudio: function disconnectAudio(disconnecttarget) {
	    var connectionindex = this._audioConnections.indexOf(disconnecttarget);
	    if (connectionindex >= 0) {
	      this._audioNode.disconnect(disconnecttarget._audioNode);
	      this._audioConnections.splice(connectionindex, 1);
	    }
	  },

	  buildAudioNode: function buildAudioNode() {
	    this._audioNode = this.createAudioNode(this._audioContext);
	    this.applyAudioNodeProps({}, this._currentElement.props);
	    this.applySpecificAudioNodeProps({}, this._currentElement.props);
	    return this._audioNode;
	  },

	  mountComponentIntoNode: function mountComponentIntoNode() {
	    throw new Error('You cannot render a Web Audio component standalone. ' + 'You need to wrap it in a WebAudioContext component.');
	  }

	};

	//
	// Audionodes that support start/stop via the "playing" prop.
	// Since playable nodes can only be started once, we have to rebuild/replace
	// the node for each start/stop cycle.
	//

	var PlayableNodeMixin = {
	  setPlayState: function setPlayState(newstate) {
	    this._playState = newstate;
	  },

	  shouldRebuildNode: function shouldRebuildNode(oldProps, props) {
	    // the 'triggerkey' prop can be use to restart a playable node
	    return props.triggerkey !== oldProps.triggerkey && this._playState !== "ready";
	  },

	  rebuildAudioNode: function rebuildAudioNode() {
	    // disconnect old audio nodes
	    if (typeof this._audioNode !== "undefined") {
	      this._audioConnections.forEach(function (disconnectto) {
	        this._audioNode.disconnect(disconnectto._audioNode);
	      }, this);
	    }

	    // build and connect the new node
	    var newaudionode = this.buildAudioNode();
	    this._audioNode = newaudionode;

	    this._audioConnections.forEach(function (connectto) {
	      newaudionode.connect(connectto._audioNode);
	    });

	    return newaudionode;
	  },

	  // used by nodes that support start/stop via the "playing" property
	  applyPlayingProp: function applyPlayingProp(oldProps, props) {
	    // by default nodes play on creation unless you tell them not to (playing=false)
	    var isplaying = typeof props.playing === "undefined" ? true : props.playing;

	    if (isplaying) {
	      switch (this._playState) {
	        case "ready":
	          // ready to play so start it
	          this._audioNode.start();
	          this.setPlayState("playing");
	          break;
	        case "playing":
	          // already playing, so no-op
	          break;
	        case "played":
	          // already played, so we need to make a new node here
	          // this builds a new node and recursively calls applySpecificAudioNodeProps,
	          // which will fall through to the "ready" case and start playing.
	          // so we don't want to call start() here.
	          this.rebuildAudioNode();
	          this._audioNode.start();
	          this.setPlayState("playing");
	          return;
	        default:
	          // need to generate a warning that the play state was not properly set/initialized
	          break;
	      }
	    } else {
	      switch (this._playState) {
	        case "ready":
	          // ready means its not running
	          break;
	        case "playing":
	          // stop it!
	          this._audioNode.stop();
	          this.setPlayState("played");
	          break;
	        case "played":
	          // already stopped
	          break;
	        default:
	          break;
	      }
	    }
	  }
	};

	//
	// Audionodes with inputs must manage children
	//

	var AudioNodeWithChildren = assign({}, ReactMultiChild.Mixin, {

	  moveChild: function moveChild(child, toIndex) {
	    /* jshint unused: vars */
	    //var childAudioNode = child._mountImage; // should be an AudioNode

	    // for audio order doesn't matter at the moment (will change if we
	    // add sidechaining)
	  },

	  createChild: function createChild(child, childAudioNode) {
	    /* jshint unused: vars */
	    // connect the child to our AuduoNode
	    child.connectAudio(this);
	    child._parentNode = this._audioNode;
	  },

	  removeChild: function removeChild(child) {
	    child.disconnectAudio(this);

	    child._mountImage = null;
	    child._parentNode = null;
	  },

	  /**
	   * Override to bypass batch updating because it is not necessary.
	   *
	   * @param {?object} nextChildren.
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @override {ReactMultiChild.Mixin.updateChildren}
	   */
	  updateChildren: function updateChildren(nextChildren, transaction, context) {
	    this._updateChildren(nextChildren, transaction, context);
	  },

	  updateChildrenAtRoot: function updateChildrenAtRoot(nextChildren, transaction) {
	    this.updateChildren(nextChildren, transaction, emptyObject);
	  },

	  // called by any container component after it gets mounted

	  mountAndAddChildren: function mountAndAddChildren(children, transaction, context) {
	    var mountedImages = this.mountChildren(children, transaction, context);
	    // Each mount image corresponds to one of the flattened children
	    var i = 0;
	    for (var key in this._renderedChildren) {
	      if (this._renderedChildren.hasOwnProperty(key)) {
	        var child = this._renderedChildren[key];
	        child._mountImage = mountedImages[i];
	        child.connectAudio(this);
	        child._parentNode = this._audioNode;
	        i++;
	      }
	    }
	  },

	  mountAndAddChildrenAtRoot: function mountAndAddChildrenAtRoot(children, transaction) {
	    this.mountAndAddChildren(children, transaction, emptyObject);
	  }
	});

	//
	// AudioNodes allow for inputs as well as outputs
	//

	var AudioNodeMixin = assign({}, OutputAudioNodeMixin, AudioNodeWithChildren, {

	  mountComponent: function mountComponent(rootID, transaction, context) {
	    /* jshint unused: vars */
	    var audioNode = OutputAudioNodeMixin.mountComponent.apply(this, arguments);

	    this.mountAndAddChildren(this._currentElement.props.children, transaction, context);
	    return audioNode;
	  },

	  receiveComponent: function receiveComponent(nextComponent, transaction, context) {
	    OutputAudioNodeMixin.receiveComponent.apply(this, arguments);
	    this.updateChildren(this._currentElement.props.children, transaction, context);
	  },

	  unmountComponent: function unmountComponent() {
	    OutputAudioNodeMixin.unmountComponent.apply(this, arguments);
	    this.unmountChildren();
	  },

	  applyAudioNodeProps: function applyAudioNodeProps(oldProps, props) {
	    var audioNode = this._audioNode;

	    if (typeof props.channelCount !== "undefined") {
	      audioNode.channelCount = props.channelCount;
	    }
	    if (typeof props.channelCountMode !== "undefined") {
	      audioNode.channelCountMode = props.channelCountMode;
	    }
	    if (typeof props.channelInterpretation !== "undefined") {
	      audioNode.channelInterpretation = props.channelInterpretation;
	    }
	  }
	});

	//
	// The 'AudioContext' component creates the Web Audio AudioContext which
	// handles the audio graph and all the mixing/outputting/etc.

	var WebAudioContext = React.createClass({
	  displayName: 'WebAudioContext',
	  mixins: [AudioNodeWithChildren],

	  componentDidMount: function componentDidMount() {
	    var props = this.props;

	    this._audioContext = new AudioContext();
	    this._audioNode = this._audioContext.destination;
	    addAudioContext(this._rootNodeID, this._audioContext);

	    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
	    transaction.perform(this.mountAndAddChildrenAtRoot, this, props.children, transaction);
	    ReactUpdates.ReactReconcileTransaction.release(transaction);

	    // invoke an audiocontextcallback if it exists
	    if (this.props.audiocontextcallback) {
	      this.props.audiocontextcallback.call(null, this._audioContext);
	    }
	  },

	  componentDidUpdate: function componentDidUpdate(oldProps) {
	    var props = this.props;
	    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
	    transaction.perform(this.updateChildrenAtRoot, this, this.props.children, transaction);
	    ReactUpdates.ReactReconcileTransaction.release(transaction);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.unmountChildren();
	    removeAudioContext(this._rootNodeID, this._audioContext);
	  },

	  render: function render() {
	    return React.createElement('div');
	  }
	});

	var OscillatorNode = defineWebAudioComponent('OscillatorNode', OutputAudioNodeMixin, PlayableNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    this.setPlayState("ready");
	    return audiocontext.createOscillator();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    var oscillatorNode = this._audioNode;
	    if (typeof props.type !== "undefined") {
	      oscillatorNode.type = props.type;

	      // custom type? then set the wave table
	      if (props.type === "custom" && typeof props.periodicWave !== "undefined" && props.type !== oldProps.type && props.periodicWave !== oldProps.periodicWave) {
	        oscillatorNode.setPeriodicWave(props.periodicWave);
	      }
	    }
	    if (typeof props.frequency !== "undefined") {
	      oscillatorNode.frequency.value = props.frequency;
	    }
	    this.applyPlayingProp(oldProps, props);
	  }
	});

	var AudioBufferSourceNode = defineWebAudioComponent('AudioBufferSourceNode', OutputAudioNodeMixin, PlayableNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    this.setPlayState("ready");
	    return audiocontext.createBufferSource();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    var bufferSourceNode = this._audioNode;
	    if (typeof props.buffer !== "undefined" && props.buffer !== oldProps.buffer) {
	      bufferSourceNode.buffer = props.buffer;
	    }
	    if (typeof props.loop !== "undefined" && props.loop !== oldProps.loop) {
	      bufferSourceNode.loop.value = props.loop;
	    }
	    if (typeof props.loopStart !== "undefined" && props.loopStart !== oldProps.loopStart) {
	      bufferSourceNode.loopStart.value = props.loopStart;
	    }
	    if (typeof props.loopEnd !== "undefined" && props.loopEnd !== oldProps.loopEnd) {
	      bufferSourceNode.loopEnd.value = props.loopEnd;
	    }
	    this.applyPlayingProp(oldProps, props);
	  }
	});

	var MediaElementAudioSourceNode = defineWebAudioComponent('MediaElementAudioSourceNode', OutputAudioNodeMixin, PlayableNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    /* jshint unused: vars */
	    this.setPlayState("ready");
	    return audiocontext.createMediaElementSource(this._currentElement.props.audioSourceElement);
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    /* jshint unused: vars */
	  }
	});

	var MediaStreamAudioSourceNode = defineWebAudioComponent('MediaStreamAudioSourceNode', OutputAudioNodeMixin, PlayableNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    /* jshint unused: vars */
	    this.setPlayState("ready");
	    return audiocontext.createMediaStreamSource(this._currentElement.props.audioSourceStream);
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    /* jshint unused: vars */
	  }
	});

	var GainNode = defineWebAudioComponent('GainNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createGain();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.gain !== "undefined") {
	      this._audioNode.gain.value = props.gain;
	    }
	  }
	});

	var filtertypes = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];

	var BiquadFilterNode = defineWebAudioComponent('BiquadFilterNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createBiquadFilter();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.frequency !== "undefined") {
	      this._audioNode.frequency.value = props.frequency;
	    }
	    if (typeof props.detune !== "undefined") {
	      this._audioNode.detune.value = props.detune;
	    }
	    if (typeof props.Q !== "undefined") {
	      this._audioNode.Q.value = props.Q;
	    }
	    if (typeof props.gain !== "undefined") {
	      this._audioNode.gain.value = props.gain;
	    }
	    if (typeof props.type !== "undefined") {
	      if (_.contains(filtertypes, props.type)) {
	        this._audioNode.type = props.type;
	      } else {
	        // error!
	        throw new Error("The filtertype in BiquadFilterNode was " + props.type + " but needs to be one of " + filtertypes.join(','));
	      }
	    }
	  }
	});

	var ConvolverNode = defineWebAudioComponent('ConvolverNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createConvolver();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.buffer !== "undefined") {
	      this._audioNode.buffer = props.buffer;
	    }

	    if (typeof props.normalize !== "undefined") {
	      this._audioNode.normalize = props.normalize;
	    }
	    // allow user to specify an array to use as impulse data

	    if (typeof props.bufferAsArray !== "undefined") {
	      // only update if the buffer data has changed
	      if (typeof oldProps.bufferAsArray === "undefined" || oldProps.bufferAsArray !== props.bufferAsArray) {
	        //this._audioNode.normalize = true;

	        // buffer configuration values
	        var bufferlength = props.bufferAsArray.length;
	        var bufferchannels = 2; //this._audioNode.numberOfInputs;
	        var buffersamplerate = this._audioNode.context.sampleRate;
	        if (typeof props.bufferAsArraySampleRate !== "undefined") {
	          buffersamplerate = props.bufferAsArraySampleRate;
	        }

	        var freshbuffer = this._audioNode.context.createBuffer(bufferchannels, bufferlength, buffersamplerate);
	        var channelindex = 0;
	        for (channelindex = 0; channelindex < bufferchannels; channelindex++) {
	          freshbuffer.getChannelData(channelindex).set(props.bufferAsArray);
	        }
	        this._audioNode.buffer = freshbuffer;
	      }
	    }
	  }
	});

	var DelayNode = defineWebAudioComponent('DelayNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createDelay();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.delayTime !== "undefined") {
	      this._audioNode.delayTime.value = props.delayTime;
	    }
	  }
	});

	var DynamicsCompressorNode = defineWebAudioComponent('DynamicsCompressorNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createDynamicsCompressor();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.threshold !== "undefined") {
	      this._audioNode.threshold.value = props.threshold;
	    }
	    if (typeof props.knee !== "undefined") {
	      this._audioNode.knee.value = props.knee;
	    }
	    if (typeof props.ratio !== "undefined") {
	      this._audioNode.ratio.value = props.ratio;
	    }
	    if (typeof props.reduction !== "undefined") {
	      this._audioNode.reduction.value = props.reduction;
	    }
	    if (typeof props.attack !== "undefined") {
	      this._audioNode.attack.value = props.attack;
	    }
	    if (typeof props.release !== "undefined") {
	      this._audioNode.release.value = props.release;
	    }
	  }
	});

	var WaveShaperNode = defineWebAudioComponent('WaveShaperNode', AudioNodeMixin, {
	  createAudioNode: function createAudioNode(audiocontext) {
	    return audiocontext.createWaveShaper();
	  },

	  applySpecificAudioNodeProps: function applySpecificAudioNodeProps(oldProps, props) {
	    if (typeof props.curve !== "undefined") {
	      this._audioNode.curve = props.curve;
	    }
	    if (typeof props.oversample !== "undefined") {
	      this._audioNode.oversample = props.oversample;
	    }
	  }
	});

	// module data

	module.exports = {
	  AudioContext: WebAudioContext,
	  OscillatorNode: OscillatorNode,
	  AudioBufferSourceNode: AudioBufferSourceNode,
	  MediaElementAudioSourceNode: MediaElementAudioSourceNode,
	  MediaStreamAudioSourceNode: MediaStreamAudioSourceNode,
	  BiquadFilterNode: BiquadFilterNode,
	  GainNode: GainNode,
	  ConvolverNode: ConvolverNode,
	  DelayNode: DelayNode,
	  DynamicsCompressorNode: DynamicsCompressorNode,
	  WaveShaperNode: WaveShaperNode,

	  render: ReactDOM.render,
	  unmountComponentAtNode: ReactDOM.unmountComponentAtNode
	};

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("react");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(3);


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("react/lib/ReactDOM");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("react/lib/ReactUpdates");

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("react/lib/ReactMultiChild");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("react/lib/Object.assign");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	//
	// time to monkey-patch React!
	//
	// a subtle bug happens when ReactCompositeComponent updates something in-place by
	// modifying HTML markup; since webaudio objects don't exist as markup the whole thing bombs.
	// we try to fix this by monkey-patching ReactCompositeComponent
	//

	"use strict";

	var ReactCompositeComponent = __webpack_require__(10);
	var ReactCompositeComponentMixin = ReactCompositeComponent.Mixin;
	var ReactReconciler = __webpack_require__(11);

	var shouldUpdateReactComponent = __webpack_require__(12);
	var warning = __webpack_require__(13);

	//
	// Composite components don't have a audionode. So we have to do some work to find
	// the proper Object3D sometimes.
	//

	function findAudioNodeChild(componentinstance) {
	  // walk downwards via _renderedComponent to find something with a displayObject
	  var componentwalker = componentinstance;
	  while (typeof componentwalker !== 'undefined') {
	    // no displayObject? then fail
	    if (typeof componentwalker._audioNode !== 'undefined') {
	      return componentwalker._audioNode;
	    }
	    componentwalker = componentwalker._renderedComponent;
	  }

	  // we walked all the way down and found no Object3D
	  return undefined;
	}

	//
	// This modified version of updateRenderedComponent will
	// manage webaudio nodes instead of HTML markup
	//
	var old_updateRenderedComponent = ReactCompositeComponentMixin._updateRenderedComponent;

	var ReactWebAudio_updateRenderedComponent = function ReactWebAudio_updateRenderedComponent(transaction, context) {
	  var prevComponentInstance = this._renderedComponent;

	  // Find the first actual rendered (non-Composite) component.
	  // If that component is a webaudio node we use the special code here.
	  // If not, we call back to the original version of updateComponent
	  // which should handle the normal (DOM) nodes.

	  var prevAudioNode = findAudioNodeChild(prevComponentInstance);
	  if (!prevAudioNode) {
	    // not an audionode, use the original DOM-style version
	    old_updateRenderedComponent.call(this, transaction, context);
	    return;
	  }

	  // This is an audio node, do a special webaudio version of updateComponent
	  var prevRenderedElement = prevComponentInstance._currentElement;
	  var nextRenderedElement = this._renderValidatedComponent();

	  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	    ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	  } else {
	    // We can't just update the current component.
	    // So we nuke the current instantiated component and put a new component in
	    // the same place based on the new props.
	    var thisID = this._rootNodeID;

	    var audioNodeParent = prevAudioNode._parentNode;

	    // unmounting doesn't disconnect the child from the parent node,
	    // but later on we'll simply overwrite the proper element in the 'children' data member
	    ReactReconciler.unmountComponent(prevComponentInstance);
	    audioNodeParent.removeChild(prevAudioNode);

	    // create the new object and stuff it into the place vacated by the old object
	    this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
	    var nextAudioNode = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	    this._renderedComponent._audioNode = nextAudioNode;

	    // fixup _mountImage as well
	    this._mountImage = nextAudioNode;

	    // overwrite the old child
	    audioNodeParent.addChild(nextAudioNode);
	  }
	};

	//
	// This generates a patched version of ReactReconciler.receiveComponent to check the type of the
	// component and patch it if it's an unpatched version of ReactCompositeComponentWrapper
	//

	var buildPatchedReceiveComponent = function buildPatchedReceiveComponent(oldReceiveComponent) {
	  var newReceiveComponent = function newReceiveComponent(internalInstance, nextElement, transaction, context) {
	    // if the instance is a ReactCompositeComponentWrapper, fixed it if needed
	    var ComponentPrototype = Object.getPrototypeOf(internalInstance);

	    // if this is a composite component it wil have _updateRenderedComponent defined
	    if (typeof ComponentPrototype._updateRenderedComponent !== 'undefined') {
	      // check first to make sure we don't patch it twice
	      if (ComponentPrototype._updateRenderedComponent !== ReactWebAudio_updateRenderedComponent) {
	        ComponentPrototype._updateRenderedComponent = ReactWebAudio_updateRenderedComponent;
	      }
	    }

	    oldReceiveComponent.call(this, internalInstance, nextElement, transaction, context);
	  };

	  return newReceiveComponent;
	};

	var ReactWebAudioMonkeyPatch = function ReactWebAudioMonkeyPatch() {

	  // in order version we patched ReactCompositeComponentMixin, but in 0.13 the
	  // prototype is wrapped in a ReactCompositeComponentWrapper so monkey-patching
	  // ReactCompositeComponentMixin won't actually have any effect.
	  //
	  // Really we want to patch ReactCompositeComponentWrapper but it's hidden inside
	  // the instantiateReactComponent module. urgh.
	  //
	  // So what we have to do is patch ReactReconciler to detect the first time an
	  // instance of ReactCompositeComponentWrapper is used, and patch it THEN
	  //
	  // urk.

	  var old_ReactReconciler_receiveComponent = ReactReconciler.receiveComponent;

	  // check to see if we already patched it, so we don't patch again
	  if (typeof old_ReactReconciler_receiveComponent._ReactWebAudioPatched === 'undefined') {
	    warning(false, "patching react to work with react-three");

	    ReactReconciler.receiveComponent = buildPatchedReceiveComponent(old_ReactReconciler_receiveComponent);
	    ReactReconciler.receiveComponent._ReactWebAudioPatched = true;
	  }
	};

	module.exports = ReactWebAudioMonkeyPatch;

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("react/lib/ReactCompositeComponent");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("react/lib/ReactReconciler");

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("react/lib/shouldUpdateReactComponent");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */

	"use strict";

	var emptyFunction = __webpack_require__(14);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */

	"use strict";

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }
/******/ ]);